* **LIP: 14**
* **Layer: Core Encoding**
* **Title: Execution Result Output Encoding Using SCTP**
* **Author: Allwin Ketnawang**
* **Created: 2025-08-03**
* **Requires: 6**
* **Status: Proposed**

## Abstract

This LIP defines the binary encoding format for the `execution_result` output mechanism within the LEA transaction processing model. The encoding is designed to be compact, deterministic, and aligned with the Simple Compact Transaction Protocol (SCTP, defined in LIP-6). Each smart contract program may emit a sequence of typed key-value pairs during execution, scoped by program ID, to be returned to the client after transaction execution. This proposal establishes the serialization structure for those res...

## Motivation

The `execution_result` mechanism allows smart contracts to output lightweight data such as balances, status codes, or created addresses. These values are ephemeral, not stored on-chain, but returned to the client. A standardized binary encoding is necessary to ensure consistency across clients, nodes, and SDKs. Leveraging SCTP ensures interoperability and simplifies integration, while ULEB128 minimizes space for common cases.

## Specification

### Encoding Overview

The `execution_result` is structured as a list of **per-program sections**. Each section is scoped to a smart contract program (identified by its 32-byte `program_id`) and contains a sequence of key-value pairs.

### Top-Level Structure

```plaintext
[ section_1 ]
[ section_2 ]
...
[ EOF (optional) ]
```

Sections are ordered **depth-first**, with results from the most deeply nested calls appearing first in the list.

Each `section` has the following format:

```plaintext
[ SCTP VECTOR (program_id: 32 bytes) ]
[ ULEB128 entry_count ]
[
  [ ULEB128 key ]
  [ value_field ]
] * entry_count
```

### Value Field Types

Each value is a single SCTP-encoded data field, using the standard SCTP type header:

| Type            | SCTP Type ID | Description                    |
|------------------|--------------|--------------------------------|
| `UINT64` (ULEB)  | 8            | Encoded using ULEB128 format   |
| `VECTOR`         | 13 / `0xDF`  | Variable-length byte array     |

- Keys are encoded as **ULEB128** values (typically small: 0–127).
- Values are encoded using **standard SCTP headers**, no extra type tags required.

### Encoding Example

A program with `program_id = 0xAB...` outputs:

- key `1` -> value `420` (ULEB128)
- key `2` -> 32-byte account address

Result:

```plaintext
// Program section:
VECTOR header      // Type = 13, length = 32 (program_id)
[32B program_id]
ULEB128(2)         // 2 entries

// Entry 1:
ULEB128(1)         // key
SCTP type: 8       // ULEB128
ULEB128(420)       // value

// Entry 2:
ULEB128(2)         // key
SCTP type: 13 (VECTOR, M=1111)
ULEB128(32)        // length
[32 bytes address]
```

### Size Limitation

The total size of the `execution_result` MUST NOT exceed **64 KB (65536 bytes) of raw SCTP-encoded data**.

- This means the limit applies to the serialized binary **as written by the host** - before any decoding or deserialization.
- Nodes MUST:
  - Track the output size during program execution
  - Abort the transaction and reject execution if the limit is exceeded
- Clients MAY:
  - Pre-simulate or estimate output size
  - Safely parse any valid output ≤ 64 KB

If writing to the `execution_result` causes the total encoded size to exceed 64 KB, the **transaction MUST be rejected entirely**.

This ensures:
- [PASS] No partial results are accepted
- [PASS] Execution is atomic
- [PASS] Fairness between programs within a transaction
- [PASS] Consistent, simple enforcement across all runtimes

### Syscall Guidelines

Three host functions may be exposed:

```c
void write_result_integer(uint64_t key, uint64_t value);
void write_result_vector(uint64_t key, uint32_t memory_ptr, uint32_t length); // Writes a variable-length byte array from memory
uint64_t get_current_result_size(); // Returns the current byte size of the result buffer
```

- The runtime encodes both key and value into the format above.
- ULEB128 encoding is applied by the host for both keys and numeric values.
- The `get_current_result_size()` function allows a contract to gracefully handle the size limit by checking the buffer size before attempting a large write.

## Rationale

This design ensures:
- **Compactness**: ULEB128 reduces size for common values.
- **Uniformity**: All values are SCTP fields — no special case parsing.
- **Extensibility**: New value types can be added via SCTP types without breaking structure.
- **Safety**: Typed headers allow deterministic decoding and validation.

ULEB128 keys were chosen over fixed-size `u16` or `SHORT` because they are typically 1 byte for common cases, saving space while supporting large key ranges. Program grouping ensures values are correctly scoped without redundant identifiers.

## Developer Experience

While integer keys are efficient, they are not human-readable. The **LEA Package Manager (`lpm`)** provides a mechanism for discoverability. A package published to `lpm` can include a metadata file that defines a schema for its result keys (e.g., `{"1": "new_balance", "2": "recipient_address"}`). Tooling can then use this schema to generate type-safe client-side code for parsing the contract's results.

## Backwards Compatibility

This proposal introduces a new `execution_result` structure that is **only valid in SCTP-enabled runtimes**. Nodes and clients using legacy CTE formats will not support this field.  
All outputs are **bounded to 64 KB** and returned in non-consensus metadata - this avoids any breaking changes to consensus-layer logic.

## Security Considerations

- A strict **64 KB limit** is enforced on the total `execution_result` size to mitigate memory abuse and DoS vectors.
- Nodes must validate:
  - All SCTP fields are correctly formed
  - Vector lengths match actual content
  - Size does not exceed cap
- `execution_result` contents are not part of consensus. A malicious node could theoretically alter this data without invalidating the block. Therefore, clients **MUST treat them as advisory and untrusted**. Critical data from a result (e.g., a price, a balance) **MUST NOT** be used to make subsequent state-changing decisions without first re-verifying that data against on-chain state.

## Copyright

This LIP is licensed under the MIT License, in alignment with the main [LEA Project](https://getlea.org) License.